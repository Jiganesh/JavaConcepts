Constructors

Once we create an object compulsory we should perform initialization then only the object is in position to respond properly.


Below code causes issue as name for all object name will be null and rollno will be 0
```java

class Student {
    String name;
    int rollno;

    public static void main(String[] args){
        Student s1 = new Student();
        Student s2 = new Student();
    }
}

```


Whenever we are creating an object some piece of the code will be executed automatically to perform initialization of the object this piece of the code is nothing but constructor. Hence the main purpose of constructor is initialization of object.


```java

class Student {
    String name;
    int rollno;

    Student (String name, int rollno){ // constructor
        this.name = name;
        this.rollno = rollno;
    }

    public static void main(String[] args){
        Student s1 = new Student("durga", 101);
        Student s2 = new Student("ravi", 101);
    }
}

```

The main purpose of constructor is to perform initialization of object but not to create object.

Difference between constructor and instance block ?

The main purpose of constructor is to perform initialization of an object but other than initialization if we want to perform any activity for every object creation then we should go for instance block (like updating one entry in database for every object creation or incrementing count value for every object creation etc)

Both constructor and instance block have their own different purposes and replacing one concept with another concept may not work always.

Both constructor and instance block will be executed for every object creation but instance block first followed by constructor


Demo program to print number of objects created for a class ðŸ‘‡

```java


class Test {
    static int count = 0

    Test (){
        count++;
    }

    Test (int i){
        count++;
    }

    Test (double i){
        count++;
    }

    public static void main(String[] args){
        Test t1 = new Test();
        Test t2 = new Test(10);
        Test t3 = new Test(10.5);

        System.out.println("The number of object created" + count); //3
    }
}
```

above you are using constructor to count which is doing code redundency and increasing number of lines of code if we use instance block it will be better


```java


class Test {
    static int count = 0

    {
        count++;
    }

    Test (){

    }

    Test (int i){

    }

    Test (double i){

    }

    public static void main(String[] args){
        Test t1 = new Test();
        Test t2 = new Test(10);
        Test t3 = new Test(10.5);

        System.out.println("The number of object created" + count); //3
    }
}
```



Rules of writing constructors : 

1. Name of the class and name of the constructor must be matched
2. return type concept not applicable for constructor even void also.
3. by mistake if we are trying to declare return type for constructor then we wont get any compile time error because compiler treats it as a method (hence it is legal but stupid to have a method whose name is exactly same as class name)
```java

class Test {
    void Test(){
        System.out.println("It is method not constructor")
    }
    Test t = new Test();
    t.Test(); // It is method not constructor
}

```
4. The only applicable modifier for constructors are public, private, protected, default if we are trying to use any other modifier we will get compile time error



```
class Test {
    static Test(){

    }
}


```

```
CE : modifier static not allowed here
```

**Default constructor**

Compiler is responsible to generate default constructor but not JVM 

If we are not writing any constructor then only compiler will generate default constructor - if we are writing atleast one constructor then compiler wont generate constructor hence every class in java can contain constructor it may be default constructor generated by compiler or customized constructor explicitly provided by programmer but not simultaneously.


**prototype of deafult constructor**

```java

class Test {
    Test(){

    }
}
```

1. It is always no-arg constructor

2.  the access modifier default constructor is exactly same as access modifier of class this rule is applicable only for public and default.

3  It contains only one line super(); it is no argument call to super class constructor

Example 1 : 

Programmer's Code

```java

class Test {

}

```


Compiler generted Code 

```java

class Test {
    Test(){
        super();
    }
}

```
---

Example 2 : 

Programmer's Code

```java

public class Test {

}

```


Compiler generted Code 

```java

class Test {
    public Test(){
        super();
    }
}

```
---
Example 3 : 

Programmer's Code

```java

public class Test {
    void Test(){

    }
}

```


Compiler generted Code 

```java

public class Test {

    public Test(){

    }

    void Test(){

    }

}

```

---
Example 4 : 

Programmer's Code

```java

class Test {
    Test(){

    }
}

```


Compiler generted Code 

```java

class Test {
    Test(){
        super();
    }

}

```
---

Example 5 : 

Programmer's Code

```java


class Test {
    Test(){
        super();
    }

}

```


Compiler generted Code 

```java


class Test {
    Test(){
        super();
    }

}

```
---

Example 6 : 

Programmer's Code

```java

class Test {

    Test(){
        this(10);
    }
    Test(int i){

    }

}

```


Compiler generted Code 

```java

class Test {
    Test(){
        this(10);
    }
    Test(int i){
        super();
    }
}

```

---

The first line inside constructor should be either super or this if we are not writing anything compiler will always place super();



---

Case 1 :

We can super() or this() in first line of constructor if we are trying to take anywhere else we will get compile time error : call to super must be fist statement in constructor

```java

class Test{
    Test(){
        System.out.println("constructor");
        super();
    }
}

```

```
CE : call to super must be fist statement in constructor

```


Case 2 : 
Within a constructor we can take either super or this but not both simultaneously CE :  call to this must be first statement in constructor.

```java

class Test{
    Test(){
        
        super();
        this();
    }
}

```

```
CE : call to this must be fist statement in constructor

```



Case 3 : We can use super() or this() only inside constructor if we are trying to use outside of constructor we will get compile time error ie we can call a constructor directly from another constructor only


```java

class Test{
    public void m1(){
        
        super();
        System.out.println("Hello");
    }
}

```


```
CE : call to super must be fist statement in constructor

```


super() or this() we can use only in constructors, only in first line and only one but not both simultaneously



| super( ), this( )  | super, this |
|-|-|
|These are constructor calls to call super class and current class constructors| These are keywords to refer super class and current class instance methods|
|We can use only in constructors as first line | We can use it anywhere except static area - If we use in static method we will get CE|
| We can use only once in constructor | We can use any number of times|



```java
class Test{
    public static void main(String[] args){
        System.out.println(Super.hashCode());
    }
}


```

```
CE : non-static variable super cannot be referenced from a static context
```



**Overloaded Constructors**

Within a class we can declare multiple constructors and all these constructors having same name but different type of arguments hence all this constructors considered as overloaded constructors hence overloading concept applicable for constructors.


```java
class Test {
    Test(){
        this(10);
        System.out.println("no-arg");
    }
    Test (int i){
        this(10.5){
            System.out.println("int-arg");
        }
    }
    Test (double d){
        System.out.println("double-arg");
    }

    public static void main(String[] args){

        Test t1 = new Test ();
        // double-arg
        // int-arg
        // no-arg

        Test t2 = new Test (10);
        // double-arg
        // int-arg

        Test t3 = new Test (10.5);
        //double-arg

        Test t4 = new Test (10l);
        //double-arg
    }
}
```

For constructors Inheritance and overridding concepts are not applicable but overloadding concept is applicable.

Every class in java including abstract class can contain constructor but interface can not contain constructor.

Case 1:


Recursive method call is runtime exception saying stackoverflow error but in our program if there is chance of recursive constructor invocation then code wont compile and we will get compile time error.

```java

class Test{
    public static void m1(){
        m2();
    }
    public static void m2(){
        m1();
    }
    public static void main(String[] args){
        m1();
        System.out.println("Hello");
    }
}

```

```
RE : StackOverflowError

```


```java


class Test{
    Test(){
        this(10);
    }
    Test (int i){
        this();
    }
    public static void main(String[] args){
        System.out.println("Hello");
    }
}


```
```
CE : recursive constructor invocation

```


Case 2 : 

```java

//valid

class P {

}

class C extends P {

}

```




```java

//valid

class P {

    P(){

    }

}

class C extends P {

}

```



```java

//invalid

class P {
    P(int i){

    }
}

class C extends P {

}

```
```

CE : cannot find symbol
Symbol : constructor P()
Location : class P
```


Note : If parent class contains any argument constructors then while writing child class we have to take special care with respect to constructors

**Whenever we are writing any argument constructor it is highly recommended to write no-arg constructor also**


Case 3 : If parent class constructor throws any checked exception compulsory child constructor should throw the same checked exception or its parent otherwise code wont compile

```java


class P {
    p() throws IOException{

    }
}

class C extends P {
    C(){
        super();
    }
}

```

CE : unreported exception java.io.IOException in default constructor




```java

//valid


class P {
    P() throws IOExceptions{

    }
}

class C extends P {
    C () throws IOException | Exception | Throwable {
        super();
    }
}

```



Which of the following is valid

The main purpose of constructor is to create an object (invalid)

The main purpose of constructor is to  perform initialization of an object (valid)

The name of the constructor need not be same as class name (Invalid)

Return type concept applicable for constructor but only void (invalid)


we can apply any modifier for constructor (invalid)


default constructor generated by JVM (invalid)


compiler is responsible to generate default constructor - valid

compiler will always generate default constructor invalid


if we are not writing no-arg constructor then compiler will generate default constructor.

Every no-argument constructor is default constructor - invalid

default constructor is always no-arg true

the first line inside constructor should be either super() or this() if we are not writing anything then compiler will generate this() - invalid

for construcstoes both overloading and onverridding concepts are application - invalid

for constructors inheritance applicable but bot overriddding - invalid

only concrete class can contains constructors but abstract classes cannot - invalid

interface can contain constructors - invalid

recursive constructor invocation is a runtime exception - invalid

if a parent class constructor throws some checked exception then compulsory child class constructor should throw the same checked exception or its child - false




